# Disable set_robust_list and rseq syscalls for Android
# These syscalls are blocked by Android's seccomp filter
# Adapted for glibc 2.40

--- a/nptl/pthread_create.c
+++ b/nptl/pthread_create.c
@@ -379,16 +379,6 @@
       __libc_fatal ("Fatal glibc error: rseq registration failed\n");
   }
 
-#ifndef __ASSUME_SET_ROBUST_LIST
-  if (__nptl_set_robust_list_avail)
-#endif
-    {
-      /* This call should never fail because the initial call in init.c
-	 succeeded.  */
-      INTERNAL_SYSCALL_CALL (set_robust_list, &pd->robust_head,
-			     sizeof (struct robust_list_head));
-    }
-
   /* This is where the try/finally block should be created.  For
      compilers without that support we do use setjmp.  */
   struct pthread_unwind_buf unwind_buf;
--- a/sysdeps/nptl/_Fork.c
+++ b/sysdeps/nptl/_Fork.c
@@ -41,8 +41,6 @@
       self->robust_prev = &self->robust_head;
 #endif
       self->robust_head.list = &self->robust_head;
-      INTERNAL_SYSCALL_CALL (set_robust_list, &self->robust_head,
-			     sizeof (struct robust_list_head));
     }
   return pid;
 }
--- a/sysdeps/nptl/dl-tls_init_tp.c
+++ b/sysdeps/nptl/dl-tls_init_tp.c
@@ -88,14 +88,9 @@
     pd->robust_head.futex_offset = (offsetof (pthread_mutex_t, __data.__lock)
                                     - offsetof (pthread_mutex_t,
                                                 __data.__list.__next));
-    int res = INTERNAL_SYSCALL_CALL (set_robust_list, &pd->robust_head,
-                                     sizeof (struct robust_list_head));
-    if (!INTERNAL_SYSCALL_ERROR_P (res))
-      {
 #ifndef __ASSUME_SET_ROBUST_LIST
-        __nptl_set_robust_list_avail = true;
+    __nptl_set_robust_list_avail = false;
 #endif
-      }
   }
 
   {
--- a/sysdeps/unix/sysv/linux/rseq-internal.h
+++ b/sysdeps/unix/sysv/linux/rseq-internal.h
--- a/sysdeps/unix/sysv/linux/rseq-internal.h
+++ b/sysdeps/unix/sysv/linux/rseq-internal.h
@@ -34,48 +34,12 @@
 extern unsigned int _rseq_size attribute_hidden;
 extern ptrdiff_t _rseq_offset attribute_hidden;
 
-#ifdef RSEQ_SIG
-static inline bool
-rseq_register_current_thread (struct pthread *self, bool do_rseq)
-{
-  if (do_rseq)
-    {
-      unsigned int size;
-#if IS_IN (rtld)
-      /* Use the hidden symbol in ld.so.  */
-      size = _rseq_size;
-#else
-      size = __rseq_size;
-#endif
-      if (size < RSEQ_AREA_SIZE_INITIAL)
-        /* The initial implementation used only 20 bytes out of 32,
-           but still expected size 32.  */
-        size = RSEQ_AREA_SIZE_INITIAL;
-
-      /* Initialize the whole rseq area to zero prior to registration.  */
-      memset (&self->rseq_area, 0, size);
-
-      /* Set the cpu_id field to RSEQ_CPU_ID_UNINITIALIZED, this is checked by
-         the kernel at registration when CONFIG_DEBUG_RSEQ is enabled.  */
-      THREAD_SETMEM (self, rseq_area.cpu_id, RSEQ_CPU_ID_UNINITIALIZED);
-
-      int ret = INTERNAL_SYSCALL_CALL (rseq, &self->rseq_area,
-                                       size, 0, RSEQ_SIG);
-      if (!INTERNAL_SYSCALL_ERROR_P (ret))
-        return true;
-    }
-  /* When rseq is disabled by tunables or the registration fails, inform
-     userspace by setting 'cpu_id' to RSEQ_CPU_ID_REGISTRATION_FAILED.  */
-  THREAD_SETMEM (self, rseq_area.cpu_id, RSEQ_CPU_ID_REGISTRATION_FAILED);
-  return false;
-}
-#else /* RSEQ_SIG */
+/* Android: rseq syscall is blocked by seccomp, always fail registration */
 static inline bool
 rseq_register_current_thread (struct pthread *self, bool do_rseq)
 {
   THREAD_SETMEM (self, rseq_area.cpu_id, RSEQ_CPU_ID_REGISTRATION_FAILED);
   return false;
 }
-#endif /* RSEQ_SIG */
 
 #endif /* rseq-internal.h */
