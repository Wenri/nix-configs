#!/system/bin/sh
# Login script using fakechroot with Android-patched glibc
#
# How it works:
# 1. Android-patched glibc has Termux patches that disable blocked syscalls
#    (clone3, rseq, set_robust_list) so glibc never triggers SIGSYS
# 2. Binaries from nixpkgs have RUNPATH pointing to standard glibc
# 3. Our rtld-audit module (pack-audit.so) does TWO things:
#    a) Redirects /nix/store -> $FAKECHROOT_BASE/nix/store (path translation)
#    b) Redirects standard glibc -> Android glibc (glibc replacement)
# 4. Result: bash loads Android glibc instead of standard glibc
#
# NO LD_LIBRARY_PATH needed! The audit module handles all path translation.

set -eu

# Base paths
PREFIX="/data/data/com.termux.nix/files/usr"
STORE="$PREFIX/nix/store"
SCRIPT_DIR="/data/data/com.termux.nix/files/home/.config/nix-on-droid/scripts"

# User configuration
export USER="wenri"
export HOME="/data/data/com.termux.nix/files/home"

# Nix store paths (update these when nix-on-droid generation changes)
# ANDROID_GLIBC: Our patched glibc with Termux patches (avoids blocked syscalls)
ANDROID_GLIBC_STORE="4c9dx2bn6wyjq5kz4x0smbfkvdr0c2qh-glibc-android-2.40-66"
# STANDARD_GLIBC: The glibc from nixpkgs binary cache (uses blocked syscalls)
STANDARD_GLIBC_STORE="89n0gcl1yjp37ycca45rn50h7lms5p6f-glibc-2.40-66"
# Other packages
BASH_STORE="9ifraby9hyh9mycwm3krfhi7q88hh6d5-bash-interactive-5.3p3"
FAKECHROOT_STORE="519zc2mj7d6m50z81ywwcp98hh1lpmrm-fakechroot-unstable-2021-02-26"
# Bash dependencies (from bash's RUNPATH)
READLINE_STORE="hkcskrw9477b457nisc0np6jdyiblp45-readline-8.3p1"
NCURSES_STORE="mk63jqhphcmx73sb4bd17aqf9kmk7hh5-ncurses-6.5"

# Full paths
LD_LINUX="$STORE/$ANDROID_GLIBC_STORE/lib/ld-linux-aarch64.so.1"
ANDROID_GLIBC_LIB="$STORE/$ANDROID_GLIBC_STORE/lib"
READLINE_LIB="$STORE/$READLINE_STORE/lib"
NCURSES_LIB="$STORE/$NCURSES_STORE/lib"
# Combined library path for ld.so (Android glibc + bash dependencies)
LIBRARY_PATH="$ANDROID_GLIBC_LIB:$READLINE_LIB:$NCURSES_LIB"
BASH_BIN="$STORE/$BASH_STORE/bin/bash"
FAKECHROOT_LIB="$STORE/$FAKECHROOT_STORE/lib/fakechroot/libfakechroot.so"
AUDIT_LIB="$SCRIPT_DIR/pack-audit.so"
LOGIN_INNER="$PREFIX/usr/lib/login-inner"

# Verify critical files exist
for _file in "$LD_LINUX" "$BASH_BIN" "$FAKECHROOT_LIB" "$AUDIT_LIB" "$LOGIN_INNER"; do
    if [ ! -e "$_file" ]; then
        echo "Error: Required file not found: $_file" >&2
        exit 1
    fi
done

# Set up fakechroot environment
export FAKECHROOT="true"
export FAKECHROOT_BASE="$PREFIX"

# ELF loader for child processes spawned by fakechroot
export FAKECHROOT_ELFLOADER="$LD_LINUX"
export FAKECHROOT_ELFLOADER_OPT_ARGV0="--argv0"

# Paths to exclude from fakechroot translation (real Android paths)
FAKECHROOT_EXCLUDE_PATH="/3rdmodem:/3rdmodemnvm:/3rdmodemnvmbkp"
FAKECHROOT_EXCLUDE_PATH="$FAKECHROOT_EXCLUDE_PATH:/acct:/apex:/android"
FAKECHROOT_EXCLUDE_PATH="$FAKECHROOT_EXCLUDE_PATH:/bugreports"
FAKECHROOT_EXCLUDE_PATH="$FAKECHROOT_EXCLUDE_PATH:/cache:/config:/cust"
FAKECHROOT_EXCLUDE_PATH="$FAKECHROOT_EXCLUDE_PATH:/d:/data:/data_mirror:/debug_ramdisk:/dev"
FAKECHROOT_EXCLUDE_PATH="$FAKECHROOT_EXCLUDE_PATH:/eng"
FAKECHROOT_EXCLUDE_PATH="$FAKECHROOT_EXCLUDE_PATH:/fstab.zram256m:/fstab.zram512m:/fstab.zram768m:/fstab.zram1024m:/fstab.zram1280m:/fstab.zram1536m:/fstab.zram2048m:/fstab.zram2240m:/fstab.zram2800m:/fstab.zram4096m:/fstab.zram6144m:/fstab.zram8192m:/fstab.zram10240m:/fstab.zram14336m"
FAKECHROOT_EXCLUDE_PATH="$FAKECHROOT_EXCLUDE_PATH:/hw_product"
FAKECHROOT_EXCLUDE_PATH="$FAKECHROOT_EXCLUDE_PATH:/init:/init.environ.rc:/init.usb.configfs.rc"
FAKECHROOT_EXCLUDE_PATH="$FAKECHROOT_EXCLUDE_PATH:/linkerconfig:/log"
FAKECHROOT_EXCLUDE_PATH="$FAKECHROOT_EXCLUDE_PATH:/metadata:/mnt:/modem_log"
FAKECHROOT_EXCLUDE_PATH="$FAKECHROOT_EXCLUDE_PATH:/odm:/odm_dlkm:/oem"
FAKECHROOT_EXCLUDE_PATH="$FAKECHROOT_EXCLUDE_PATH:/patch_hw:/postinstall:/preas:/preavs:/preload:/prets:/pretvs:/proc:/product"
FAKECHROOT_EXCLUDE_PATH="$FAKECHROOT_EXCLUDE_PATH:/res:/resetFactory.cfg"
FAKECHROOT_EXCLUDE_PATH="$FAKECHROOT_EXCLUDE_PATH:/sdcard:/sec_storage:/second_stage_resources:/splash2:/storage:/sys:/system:/system_ext"
FAKECHROOT_EXCLUDE_PATH="$FAKECHROOT_EXCLUDE_PATH:/vendor:/vendor_dlkm:/verity_key:/version"
export FAKECHROOT_EXCLUDE_PATH

# LD_AUDIT and LD_PRELOAD for child processes
export LD_AUDIT="$AUDIT_LIB"
export LD_PRELOAD="$FAKECHROOT_LIB"

# glibc redirection: tell pack-audit.so to redirect standard glibc -> Android glibc
# This is the key to making binary-cached packages work on Android!
export STANDARD_GLIBC="$STANDARD_GLIBC_STORE"
export ANDROID_GLIBC="$ANDROID_GLIBC_STORE"

# Debug mode: set PACK_AUDIT_DEBUG=1 to see path redirections
export PACK_AUDIT_DEBUG=1

# Execute using Android glibc's ld.so
# --argv0: Set argv[0] to bash instead of ld-linux.so
# --library-path: Set library search path (glibc + bash deps: readline, ncurses)
# --audit: Load pack-audit.so for /nix/store path rewriting
# --preload: Preload libfakechroot.so for syscall interception
exec "$LD_LINUX" \
    --argv0 "$BASH_BIN" \
    --library-path "$LIBRARY_PATH" \
    --audit "$AUDIT_LIB" \
    --preload "$FAKECHROOT_LIB" \
    "$BASH_BIN" "$LOGIN_INNER" "$@"
